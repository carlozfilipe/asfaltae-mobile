{"version":3,"sources":["../browser/src/subscriber/Broadcaster.ts"],"names":[],"mappings":"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","file":"Broadcaster.js","sourcesContent":["import {EntitySubscriberInterface} from \"./EntitySubscriberInterface\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {BroadcasterResult} from \"./BroadcasterResult\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\n\ninterface BroadcasterEvents {\n    \"BeforeTransactionCommit\": () => void;\n    \"AfterTransactionCommit\": () => void;\n    \"BeforeTransactionStart\": () => void;\n    \"AfterTransactionStart\": () => void;\n    \"BeforeTransactionRollback\": () => void;\n    \"AfterTransactionRollback\": () => void;\n\n    \"BeforeUpdate\": (metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral, updatedColumns?: ColumnMetadata[], updatedRelations?: RelationMetadata[]) => void;\n    \"AfterUpdate\": (metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral, updatedColumns?: ColumnMetadata[], updatedRelations?: RelationMetadata[]) => void;\n\n    \"BeforeInsert\": (metadata: EntityMetadata, entity: ObjectLiteral | undefined) => void;\n    \"AfterInsert\": (metadata: EntityMetadata, entity: ObjectLiteral | undefined) => void;\n\n    \"BeforeRemove\": (metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral) => void;\n    \"AfterRemove\": (metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral) => void;\n\n    \"BeforeSoftRemove\": (metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral) => void;\n    \"AfterSoftRemove\": (metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral) => void;\n\n    \"BeforeRecover\": (metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral) => void;\n    \"AfterRecover\": (metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral) => void;\n\n    \"Load\": (metadata: EntityMetadata, entities: ObjectLiteral[]) => void;\n}\n\n\n/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\nexport class Broadcaster {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private queryRunner: QueryRunner) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async broadcast<U extends keyof BroadcasterEvents>(event: U, ...args: Parameters<BroadcasterEvents[U]>): Promise<void> {\n        const result = new BroadcasterResult();\n\n        const broadcastFunction = this[`broadcast${event}Event` as keyof this];\n\n        if (typeof broadcastFunction === \"function\") {\n            (broadcastFunction as any).call(\n                this,\n                result,\n                ...args\n            );\n        }\n\n        await result.wait();\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\" event.\n     * Before insert event is executed before entity is being inserted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeInsertEvent(result: BroadcasterResult, metadata: EntityMetadata, entity: undefined | ObjectLiteral): void {\n\n        if (entity && metadata.beforeInsertListeners.length) {\n            metadata.beforeInsertListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {\n                    const executionResult = subscriber.beforeInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_UPDATE\" event.\n     * Before update event is executed before entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeUpdateEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral, updatedColumns?: ColumnMetadata[], updatedRelations?: RelationMetadata[]): void { // todo: send relations too?\n        if (entity && metadata.beforeUpdateListeners.length) {\n            metadata.beforeUpdateListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {\n                    const executionResult = subscriber.beforeUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || []\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_REMOVE\" event.\n     * Before remove event is executed before entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeRemoveEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\n        if (entity && metadata.beforeRemoveListeners.length) {\n            metadata.beforeRemoveListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {\n                    const executionResult = subscriber.beforeRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_SOFT_REMOVE\" event.\n     * Before soft remove event is executed before entity is being soft removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeSoftRemoveEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\n        if (entity && metadata.beforeSoftRemoveListeners.length) {\n            metadata.beforeSoftRemoveListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeSoftRemove) {\n                    const executionResult = subscriber.beforeSoftRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_RECOVER\" event.\n     * Before recover event is executed before entity is being recovered in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeRecoverEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\n        if (entity && metadata.beforeRecoverListeners.length) {\n            metadata.beforeRecoverListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRecover) {\n                    const executionResult = subscriber.beforeRecover({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\" event.\n     * After insert event is executed after entity is being persisted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterInsertEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral): void {\n\n        if (entity && metadata.afterInsertListeners.length) {\n            metadata.afterInsertListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {\n                    const executionResult = subscriber.afterInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_START\" event.\n     */\n    broadcastBeforeTransactionStartEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.beforeTransactionStart) {\n                    const executionResult = subscriber.beforeTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_START\" event.\n     */\n    broadcastAfterTransactionStartEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.afterTransactionStart) {\n                    const executionResult = subscriber.afterTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\n     */\n    broadcastBeforeTransactionCommitEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.beforeTransactionCommit) {\n                    const executionResult = subscriber.beforeTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\n     */\n    broadcastAfterTransactionCommitEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.afterTransactionCommit) {\n                    const executionResult = subscriber.afterTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastBeforeTransactionRollbackEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.beforeTransactionRollback) {\n                    const executionResult = subscriber.beforeTransactionRollback({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastAfterTransactionRollbackEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.afterTransactionRollback) {\n                    const executionResult = subscriber.afterTransactionRollback({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_UPDATE\" event.\n     * After update event is executed after entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterUpdateEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral, updatedColumns?: ColumnMetadata[], updatedRelations?: RelationMetadata[]): void {\n\n        if (entity && metadata.afterUpdateListeners.length) {\n            metadata.afterUpdateListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {\n                    const executionResult = subscriber.afterUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || []\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_REMOVE\" event.\n     * After remove event is executed after entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterRemoveEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\n\n        if (entity && metadata.afterRemoveListeners.length) {\n            metadata.afterRemoveListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {\n                    const executionResult = subscriber.afterRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_SOFT_REMOVE\" event.\n     * After soft remove event is executed after entity is being soft removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterSoftRemoveEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\n\n        if (entity && metadata.afterSoftRemoveListeners.length) {\n            metadata.afterSoftRemoveListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterSoftRemove) {\n                    const executionResult = subscriber.afterSoftRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_RECOVER\" event.\n     * After recover event is executed after entity is being recovered in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterRecoverEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\n\n        if (entity && metadata.afterRecoverListeners.length) {\n            metadata.afterRecoverListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRecover) {\n                    const executionResult = subscriber.afterRecover({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * @deprecated Use `broadcastLoadForAllEvent`\n     */\n    broadcastLoadEventsForAll(result: BroadcasterResult, metadata: EntityMetadata, entities: ObjectLiteral[]): void {\n        return this.broadcastLoadEvent(result, metadata, entities);\n    }\n\n    /**\n     * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n     * After load event is executed after entity has been loaded from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastLoadEvent(result: BroadcasterResult, metadata: EntityMetadata, entities: ObjectLiteral[]): void {\n        // Calculate which subscribers are fitting for the given entity type\n        const fittingSubscribers = this.queryRunner.connection.subscribers.filter(subscriber => this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad);\n\n        if (metadata.relations.length || metadata.afterLoadListeners.length || fittingSubscribers.length) {\n            // todo: check why need this?\n            const nonPromiseEntities = entities.filter(entity => !(entity instanceof Promise));\n\n            // collect load events for all children entities that were loaded with the main entity\n            if (metadata.relations.length) {\n                metadata.relations.forEach(relation => {\n                    nonPromiseEntities.forEach(entity => {\n                        // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n                        if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName)) return;\n\n                        const value = relation.getEntityValue(entity);\n                        if (value instanceof Object) this.broadcastLoadEvent(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [value]);\n                    });\n                });\n            }\n\n            if (metadata.afterLoadListeners.length) {\n                metadata.afterLoadListeners.forEach(listener => {\n                    nonPromiseEntities.forEach(entity => {\n                        if (listener.isAllowed(entity)) {\n                            const executionResult = listener.execute(entity);\n                            if (executionResult instanceof Promise) result.promises.push(executionResult);\n                            result.count++;\n                        }\n                    });\n                });\n            }\n\n            fittingSubscribers.forEach(subscriber => {\n                nonPromiseEntities.forEach(entity => {\n                    const executionResult = subscriber.afterLoad!(entity, {\n                        entity,\n                        metadata,\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise) result.promises.push(executionResult);\n                    result.count++;\n                });\n            });\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n     * or listens our entity.\n     */\n    protected isAllowedSubscriber(subscriber: EntitySubscriberInterface<any>, target: Function|string): boolean {\n        return  !subscriber.listenTo ||\n            !subscriber.listenTo() ||\n            subscriber.listenTo() === Object ||\n            subscriber.listenTo() === target ||\n            subscriber.listenTo().isPrototypeOf(target);\n    }\n\n}\n"],"sourceRoot":".."}