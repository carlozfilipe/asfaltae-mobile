{"version":3,"sources":["../../src/commands/CommandUtils.ts"],"names":[],"mappings":";;;;AAAA,kDAAyB;AACzB,sDAA6B;AAC7B,+DAA4B;AAC5B,kCAAsC;AAEtC;;GAEG;AACH;IAAA;IA6CA,CAAC;IA3CG;;OAEG;IACI,8BAAiB,GAAxB,UAAyB,SAAiB;QACtC,OAAO,IAAA,gBAAM,EAAC,SAAS,CAAC,CAAC;IAC7B,CAAC;IAED;;OAEG;IACU,uBAAU,GAAvB,UAAwB,QAAgB,EAAE,OAAe,EAAE,QAAwB;QAAxB,yBAAA,EAAA,eAAwB;;;;4BAC/E,qBAAM,YAAY,CAAC,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,EAAA;;wBAA5D,SAA4D,CAAC;wBAC7D,sBAAO,IAAI,OAAO,CAAO,UAAC,EAAE,EAAE,IAAI;gCAC9B,IAAI,QAAQ,KAAK,KAAK,IAAI,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC;oCAC7C,OAAO,EAAE,EAAE,CAAC;gCAEhB,EAAE,CAAC,SAAS,CAAC,QAAQ,EAAE,OAAO,EAAE,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,EAAtB,CAAsB,CAAC,CAAC;4BACnE,CAAC,CAAC,EAAC;;;;KACN;IAED;;OAEG;IACU,qBAAQ,GAArB,UAAsB,QAAgB;;;gBAClC,sBAAO,IAAI,OAAO,CAAS,UAAC,EAAE,EAAE,IAAI;wBAChC,EAAE,CAAC,QAAQ,CAAC,QAAQ,EAAE,UAAC,GAAG,EAAE,IAAI,IAAK,OAAA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAArC,CAAqC,CAAC,CAAC;oBAChF,CAAC,CAAC,EAAC;;;KACN;IAGY,uBAAU,GAAvB,UAAwB,QAAgB;;;gBACpC,sBAAO,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAC;;;KAClC;IAED;;OAEG;IACI,yBAAY,GAAnB,UAAoB,uBAA4B;QAC5C,IAAI,uBAAuB,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC,IAAI,uBAAuB,GAAG,CAAC,CAAC,EAAE;YAC5F,MAAM,IAAI,oBAAY,CAAC,sEAA+D,uBAAuB,CAAE,CAAC,CAAC;SACpH;QACD,OAAO,uBAAuB,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,uBAAuB,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;IACtG,CAAC;IACL,mBAAC;AAAD,CA7CA,AA6CC,IAAA;AA7CY,oCAAY","file":"CommandUtils.js","sourcesContent":["import * as fs from \"fs\";\nimport * as path from \"path\";\nimport mkdirp from \"mkdirp\";\nimport {TypeORMError} from \"../error\";\n\n/**\n * Command line utils functions.\n */\nexport class CommandUtils {\n\n    /**\n     * Creates directories recursively.\n     */\n    static createDirectories(directory: string) {\n        return mkdirp(directory);\n    }\n\n    /**\n     * Creates a file with the given content in the given path.\n     */\n    static async createFile(filePath: string, content: string, override: boolean = true): Promise<void> {\n        await CommandUtils.createDirectories(path.dirname(filePath));\n        return new Promise<void>((ok, fail) => {\n            if (override === false && fs.existsSync(filePath))\n                return ok();\n\n            fs.writeFile(filePath, content, err => err ? fail(err) : ok());\n        });\n    }\n\n    /**\n     * Reads everything from a given file and returns its content as a string.\n     */\n    static async readFile(filePath: string): Promise<string> {\n        return new Promise<string>((ok, fail) => {\n            fs.readFile(filePath, (err, data) => err ? fail(err) : ok(data.toString()));\n        });\n    }\n\n\n    static async fileExists(filePath: string) {\n        return fs.existsSync(filePath);\n    }\n\n    /**\n     * Gets migration timestamp and validates argument (if sent)\n     */\n    static getTimestamp(timestampOptionArgument: any): number {\n        if (timestampOptionArgument && (isNaN(timestampOptionArgument) || timestampOptionArgument < 0)) {\n            throw new TypeORMError(`timestamp option should be a non-negative number. received: ${timestampOptionArgument}`);\n        }\n        return timestampOptionArgument ? new Date(Number(timestampOptionArgument)).getTime() : Date.now();\n    }\n}\n"],"sourceRoot":".."}